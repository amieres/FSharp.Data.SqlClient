      <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>A comparison on SQL Server data access methods
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="SqlCommandProvider provides statically typed access to input parameters and result set of T-SQL command in idiomatic F# way. SqlProgrammabilityProvider exposes Stored Procedures, User-Defined Types and User-Defined Functions in F# code.">
    <meta name="author" content="Dmitry Morozov, Dmitry Sevastianov">

    <script src="//code.jquery.com/jquery-1.8.0.js"></script>
    <script src="//code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet" />

    <link type="text/css" rel="stylesheet" href="./content/style.css" />
    <script type="text/javascript" src="./content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <div class="container">
        <div class="masthead">
            <ul class="nav nav-pills pull-right">
                <li><a href="http://fsharp.org">fsharp.org</a></li>
                <li><a href="http://fsprojects.github.io/">fsprojects</a></li>
                <li><a href="http://github.com/fsprojects/FSharp.Data.SqlClient">github page</a></li>
            </ul>
            <h3 class="muted">FSharp.Data.SqlClient</h3>
        </div>
        <hr />
        <div class="row">
            <div class="span9" id="main">
                
<h1>A comparison on SQL Server data access methods</h1>

<h2>Type providers + Query Expressions</h2>

<p>F# Query Expressions (aka LINQ 2.0) is lovely and useful technology. It makes writing data access code a pleasant exercise.
 There are several different implementations available: <a href="http://github.com/fsprojects/SQLProvider">SQLProvider</a> (recent community effort), <a href="http://msdn.microsoft.com/en-us/library/hh361033.aspx">SqlDataConnection</a>/<a href="http://msdn.microsoft.com/en-us/library/hh361039.aspx">DbmlFile</a>
 and <a href="http://msdn.microsoft.com/en-us/library/hh361035.aspx">SqlEntityConnection</a>/<a href="http://msdn.microsoft.com/en-us/library/hh361038.aspx">EdmxFile</a>.</p>

<p>But I would like to point out some reasons you might prefer SqlCommandProvider over those.
 Take a look at this  <a href="http://stackoverflow.com/questions/21574254/how-do-i-do-a-contains-query-with-f-query-expressions/21584169">StackOverflow issue</a>. There are dozens of similar questions (hundreds if you include C# LINQ which is essentially
 the same issue).</p>

<p>So, what's a deal? The thing is, you can have perfectly valid F# code that compiles but still fails at run-time because of
 unsupported F#-to-SQL translation semantics. Contrary, SqlCommandProvider offers "What You See Is What You Get" approach.
 Once F# code involving SqlCommandProvider passes compilation stage you are guaranteed to have valid executable (both F# code and T-SQL).</p>

<p>Lack of control and opaqueness of F#-to-SQL conversion spells performance problems too.
 At times developers are really frustrated by ineffective T-SQL code generated by type providers (most of EF users are aware of this issue).
 Evolution and changes in T-SQL code generated by type provider may present certain problems too.
 A data access code that is performing well today can become suboptimal tomorrow.
 SqlCommandProvider gives you direct access to full power of T-SQL scripting including the latest features which are often
 unavailable in type providers because they target older or different versions of the system.</p>

<h3>Common for all TypeProviders</h3>

<ul>
<li>You write logic, not POCO-objects and mappings</li>
<li>If your database changes, your code breaks at compile time</li>
<li>No SQL-injection vulnerabilities</li>
<li>Commit to existing transactions so you can mix with other technologies</li>
<li>You can call stored procedures if needed</li>
<li>Joins and nested in-queries are supported so you can avoid "n+1 database hits" problems</li>
</ul>

<h3>FSharp.Data.SqlClient</h3>

<p>Good:</p>

<ul>
<li>User has full control of SQL</li>
<li>Which allows full utilization of database indexes with complex queries</li>
<li>SQL syntax is already familiar for many</li>
<li>Exposes database objects directly in code</li>
<li>Supports async database operations</li>
<li>Used in production for enterprise development for years</li>
<li>Open source</li>
</ul>

<p>Not so good:</p>

<ul>
<li>By default supports only Microsoft SQLServer and T-SQL</li>
<li>Code overhead if you have a large amount of different small operations</li>
<li>Doesn't generate domain model for work with C#</li>
<li>No support for .NET Standard / .NET Core</li>
</ul>

<h3>SQLProvider</h3>

<p>Good:</p>

<ul>
<li>Supports any database (MSSQL, MySQL, PostgreSQL, Oracle, Odbc, ...)</li>
<li>Supports .NET Standard and .NET Core</li>
<li>Changing the database is not actually huge work</li>
<li>Makes effective simple SQL</li>
<li>Supports async database operations</li>
<li>Used in production for enterprise development for years</li>
<li>Simplifies user code</li>
<li>Open source</li>
</ul>

<p>Not so good:</p>

<ul>
<li>No Manual control over generated SQL</li>
<li>FSharp/LINQ query-syntax is a learning curve</li>
<li>Doesn't generate domain model for work with C#</li>
<li>Most LINQ-operations supported, but not yet complex group-by scenarios</li>
<li>Updates in complex scenarios can be a pain</li>
</ul>

<h3>SqlDataConnection</h3>

<p>Good:</p>

<ul>
<li>You can use generated DB-model from C#-projects</li>
<li>Supports even complex LINQ-operations</li>
<li>Used in production for enterprise development for years</li>
</ul>

<p>Not so good:</p>

<ul>
<li>Generates EF-models in background</li>
<li>Not dynamic</li>
<li>Doesn't scale to large databases</li>
<li>FSharp/LINQ query-syntax is a learning curve</li>
<li>Closed source</li>
<li>Supports only Microsoft SQLServer</li>
<li>No support for .NET Standard / .NET Core</li>
</ul>

<h3>Rezoom.SQL</h3>

<p>Good:</p>

<ul>
<li>User has full control of SQL</li>
<li>Which allows full utilization of database indexes with complex queries</li>
<li>SQL syntax is already familiar for many</li>
<li>Supports SQLite, SQL Server, and PostgreSQL</li>
<li>Open source</li>
</ul>

<p>Not so good:</p>

<ul>
<li>No support for .NET Standard / .NET Core</li>
<li>No support for MySQL, Oracle, ...</li>
<li>Code overhead if you have a large amount of different small operations</li>
<li>Doesn't generate domain model for work with C#</li>
</ul>

<h2><a href="https://code.google.com/p/dapper-dot-net/">Dapper</a></h2>

<p>FSharp.Data.SqlClient is much closer to the family of micro-ORMs rather than complete solutions like EntityFramework and NHibernate,
hence comparison with the best of the breed - Dapper.</p>

<p>Dapper is a micro-ORM by StackOverflow with a main goal of being extremely fast. Here is a <a href="http://stackoverflow.com/tags/dapper/info">description</a>
from StackOverflow itself:</p>

<blockquote>
  <p>dapper is a micro-ORM, offering core parameterization and materialization services, but (by design) not the full breadth of services that you might
expect in a full ORM such as LINQ-to-SQL or Entity Framework. Instead, it focuses on making the materialization as fast as possible, with no overheads
from things like identity managers - just "run this query and give me the (typed) data".</p>
</blockquote>

<p>Let's start with performance to get it out of the way.</p>

<p>Dapper comes with an excellent <a href="https://code.google.com/p/dapper-dot-net/source/browse/Tests/PerformanceTests.cs">benchmark</a>.
The focus of the test is on deserialization. Here is how FSHarp.Data.SqlClient compares with all major .Net ORMs:</p>

<img src="img/dapper.png"/>

<p>Tests were executed against SqlExpress 2012 so the numbers are a bit higher than what you can see on
<a href="https://github.com/SamSaffron/dapper-dot-net#performance-of-select-mapping-over-500-iterations---poco-serialization">Dapper page</a>.
A test retrieves single record with 13 properties by random id 500 times and deserializes it. Runs for different ORMs are mixed up randomly.
All executions are synchronous.</p>

<p>Note that we didn't put any specific effort into improving FSharp.Data.SqlClient performance for this test. The very nature of type providers helps to produce
the simplest run-time implementation and hence be as close as possible to hand-coded ADO.NET code.</p>

<p>Now, to the usage. Line-by-line comparison is probably unfair as I'll end up comparing C# with F#, and C# is going to lose.
Keeping in mind that FSharp.Data.SqlClient is not strictly an ORM in commonly understood sense of the term, here are the some pros and cons:</p>

<ul>
<li>Because result types are auto-generated, FSharp.Data.SqlClient doesn't support so-called <a href="http://stackoverflow.com/a/6001902/862313">multi-mapping</a></li>
<li>As FSharp.Data.SqlClient is based on features specific for Sql Server 2012; Dapper provides better range of supported scenarios, including Mono</li>
<li>Other side of this is that FSharp.Data.SqlClient fully supports SqlServer-specific types like <a href="http://technet.microsoft.com/en-us/library/bb677173.aspx">hierarchyId</a> and
<a href="http://blogs.msdn.com/b/adonet/archive/2013/12/09/microsoft-sqlserver-types-nuget-package-spatial-on-azure.aspx">spatial types</a>, which Dapper does not</li>
<li>FSharp.Data.SqlClient fully supports User-Defined Table Types for input parameters with no additional coding required,
<a href="http://stackoverflow.com/questions/6232978/does-dapper-support-sql-2008-table-valued-parameters">as opposed to Dapper</a></li>
<li>Dapper intentionally  has no support for <code>SqlConnection</code> management; FSharp.Data.SqlClient encapsulates <code>SqlConnection</code>
life-cycle including asynchronous scenarios while optionally accepting external <code>SqlTransaction</code>.</li>
</ul>

<p>Following FSharp.Data.SqlClient features are unique:</p>

<ul>
<li>Reasonable auto-generated result type definition so there is no need to define it in code</li>
<li>This type also comes with <code>IDictionary&lt;string,obj&gt;</code> and <code>DynamicObject</code> implementation</li>
<li>Sql command is just a string for other ORMs, while FSHarp.Data.SqlClient verifies it and figures out input parameters and output types
so design-time experience is simply unparalleled</li>
<li>Design-time verification means less run-time tests, less yak shaving synchronizing database schema with code definitions, and earliest possible
identification of bugs and mismatches</li>
<li><code>SqlProgrammabilityProvider</code> lets user to explore stored procedures and user-defined functions right from the code with IntelliSense</li>
</ul>

<p>It is my believe that FSharp.Data.SqlClient comes closest to the mission of micro-ORM - to make conversion between data stored in database and .Net run-time types as painless as possible
while keeping away from <a href="http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch">object-relational impedance mismatch</a>
as described in famous blog <a href="http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx">The Vietnam of Computer Science</a> by Ted Neward.</p>

<h2><a href="http://msdn.microsoft.com/en-us/library/wha85tzb.aspx">Generating strongly typed DataSets</a></h2>

<p>Using strongly typed DataSets requires creation of XSD schema which then used to generate C# code. Dubious pleasure of hand-crafting XSD aside,
this traditional technique suffers from the same limitation as Entity Framework and such when compared to FSharp.Data.SqlClient:
no design-time interaction with model database - it is up to a user to keep definitions and database schema in sync.</p>

<p>At the same time, FSharp.Data.SqlClient supports strongly typed data table as one of the result types. No XSD required.</p>


            </div>

            <div class="span3">
                <a href="http://www.nuget.org/packages/FSharp.Data.SqlClient">
                    <img src="img/logo.png" style="width: 200px; height: 200px; margin: 10px 0px 0px 35px; border-style: none;" />
                </a>
                <ul class="nav nav-list" id="menu">
                    <li class="nav-header">F# SqlClient</li>
                    <li><a href="./index.html">Home page</a></li>
                    <li class="divider"></li>
                    <li><a href="http://www.nuget.org/packages/FSharp.Data.SqlClient">Get Library via NuGet</a></li>
                    <li><a href="http://github.com/fsprojects/FSharp.Data.SqlClient">Source Code on GitHub</a></li>
                    <li><a href="http://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/LICENSE.md">License</a></li>
                    <li><a href="http://github.com/fsprojects/FSharp.Data.SqlClient/blob/master/RELEASE_NOTES.md">Release Notes</a></li>

                    <li class="nav-header">Documentation</li>
                    <li><a href="./whatsnew.html">What's New</a></li>
                    <li><a href="./netcore.html">Support for .NET Core</a></li>
                    <li><a href="./configuration and input.html">Configuration and Input</a></li>
                    <li><a href="./output.html">Output</a></li>                    
                    <li><a href="./faq.html">FAQ</a></li>
                    <li class="divider"></li>
                    <li><a href="./data modification.html">Data Modification</a></li>
                    <li><a href="./transactions.html">Transactions</a></li>
                    <li class="divider"></li>
                    <li><a href="./debugging.html">Debugging</a></li>
                    <li><a href="./unit-testing.html">Unit Testing</a></li>
                    <li class="divider"></li>
                    <li><a href="./comparison.html">Comparison</a></li>
                    <li><a href="./dynamic local db.html">Dynamic local db</a></li>
                    <li class="divider"></li>
                    <li><a href="./sqlenumprovider.quickstart.html">SqlEnumProvider</a></li>

                    <li class="nav-header">Tools</li>
                    <li><a href="http://tpetricek.github.io/FSharp.Formatting/">F# Formatting</a></li>
                    <li><a href="http://fsharp.github.io/FAKE/">FAKE</a></li>
                    <li><a href="http://fsprojects.github.io/ProjectScaffold/">F# open-source project scaffolding</a></li>
                    <li><a href="http://tomasp.net/blog/2013/great-open-source/index.html">Building great open-source libraries</a></li>
                </ul>
            </div>
        </div>
    </div>
    <a href="http://github.com/fsprojects/FSharp.Data.SqlClient">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub">
    </a>
</body>
</html>
